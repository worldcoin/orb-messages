#![forbid(unsafe_code)]

#[cfg(not(test))]
use std::fs;
#[cfg(not(test))]
use std::path::Path;

#[cfg(not(test))]
fn main() {
    // NOTE: We cannot use `CARGO_MANIFEST_DIR`, because protoc doesn't work well with
    // absolute paths.
    #[allow(clippy::eq_op)]
    let is_public = std::env::var("CARGO_PKG_REPOSITORY").unwrap()
        == "https://github.com/worldcoin/orb-messages";
    let (messages_dir, priv_dir) = if is_public {
        println!("cargo:warning=Be aware that private definitions are stubbed out when building the public crate.");

        (Path::new("messages"), Path::new("messages/private_stub"))
    } else {
        (Path::new("public/messages"), Path::new("private"))
    };

    // rebuild if any of this changes
    println!("cargo:rerun-if-env-changed=PROTOC");
    println!("cargo:rerun-if-env-changed=PROTOC_INCLUDE");
    println!("cargo:rerun-if-changed={}", messages_dir.display());
    println!("cargo:rerun-if-changed={}", priv_dir.display());

    // These protos and any others that are imported by them will get compiled
    prost_build::Config::default()
        // Add serde derives to all messages (structs)
        .type_attribute(
            ".",
            "#[derive(crate::serde::Serialize, crate::serde::Deserialize)]",
        )
        .compile_protos(&[messages_dir.join("mcu.proto")], &[messages_dir, priv_dir])
        .expect("failed to compile protobufs");

    // Generate ZenohKey implementations
    let zenoh_keys = generate_zenoh_keys(messages_dir);
    let out_dir = std::env::var("OUT_DIR").unwrap();
    fs::write(Path::new(&out_dir).join("zenoh_keys.rs"), zenoh_keys)
        .expect("failed to write zenoh_keys.rs");
}

/// Generates ZenohKey trait implementations for payload enums.
///
/// Only payload fields marked with `// @zenoh` in the proto file will have
/// zenoh suffix keys generated. Unmarked payloads return `Err(NotAZenohPayload)`.
#[cfg(not(test))]
fn generate_zenoh_keys(messages_dir: &Path) -> String {
    let main_proto = fs::read_to_string(messages_dir.join("main.proto"))
        .expect("failed to read main.proto");
    let sec_proto = fs::read_to_string(messages_dir.join("sec.proto"))
        .expect("failed to read sec.proto");

    // Extract only @zenoh-marked payload variants from each message
    let main_payloads = extract_oneof_payloads(&main_proto, "McuToJetson");
    let sec_payloads = extract_oneof_payloads(&sec_proto, "SecToJetson");

    let mut output = String::from(
        "// Auto-generated ZenohKey implementations for @zenoh-marked payloads\n\
         // Do not edit manually - generated by build.rs\n\n",
    );

    // Generate impl for main::mcu_to_jetson::Payload
    output.push_str(
        "impl crate::mcu_zenoh::ZenohKey for crate::main::mcu_to_jetson::Payload {\n",
    );
    output.push_str("    fn zenoh_suffix_key(&self) -> Result<&'static str, crate::mcu_zenoh::NotAZenohPayload> {\n");
    output.push_str("        match self {\n");
    for (variant_name, _field_name) in &main_payloads {
        let snake_name = to_snake_case(variant_name);
        output.push_str(&format!(
            "            Self::{}(_) => Ok(\"mcu/main/{}\"),\n",
            variant_name, snake_name
        ));
    }
    // Catch-all for payloads not marked with @zenoh
    output.push_str("            _ => Err(crate::mcu_zenoh::NotAZenohPayload),\n");
    output.push_str("        }\n");
    output.push_str("    }\n");
    output.push_str("}\n\n");

    // Generate impl for sec::sec_to_jetson::Payload
    output.push_str(
        "impl crate::mcu_zenoh::ZenohKey for crate::sec::sec_to_jetson::Payload {\n",
    );
    output.push_str("    fn zenoh_suffix_key(&self) -> Result<&'static str, crate::mcu_zenoh::NotAZenohPayload> {\n");
    output.push_str("        match self {\n");
    for (variant_name, _field_name) in &sec_payloads {
        let snake_name = to_snake_case(variant_name);
        output.push_str(&format!(
            "            Self::{}(_) => Ok(\"mcu/sec/{}\"),\n",
            variant_name, snake_name
        ));
    }
    // Catch-all for payloads not marked with @zenoh
    output.push_str("            _ => Err(crate::mcu_zenoh::NotAZenohPayload),\n");
    output.push_str("        }\n");
    output.push_str("    }\n");
    output.push_str("}\n");

    output
}

/// Extracts oneof payload variants marked with `@zenoh` from a protobuf message definition.
/// Returns a Vec of (VariantName, field_name) tuples where VariantName is PascalCase.
///
/// The `@zenoh` marker can appear:
/// - On the same line as the field: `orb.mcu.Versions versions = 6; // @zenoh`
/// - On a comment line before the field: `// @zenoh` followed by the field
fn extract_oneof_payloads(
    proto_content: &str,
    message_name: &str,
) -> Vec<(String, String)> {
    let mut payloads = Vec::new();

    // Find the message block
    let message_pattern = format!("message {}", message_name);
    let Some(message_start) = proto_content.find(&message_pattern) else {
        return payloads;
    };

    // Find the oneof payload block within this message
    let message_content = &proto_content[message_start..];
    let Some(oneof_start) = message_content.find("oneof payload") else {
        return payloads;
    };

    // Find the opening brace of the oneof
    let oneof_content = &message_content[oneof_start..];
    let Some(brace_start) = oneof_content.find('{') else {
        return payloads;
    };

    // Find the matching closing brace
    let mut brace_count = 1;
    let mut brace_end = brace_start + 1;
    for (i, c) in oneof_content[brace_start + 1..].chars().enumerate() {
        match c {
            '{' => brace_count += 1,
            '}' => {
                brace_count -= 1;
                if brace_count == 0 {
                    brace_end = brace_start + 1 + i;
                    break;
                }
            }
            _ => {}
        }
    }

    let oneof_block = &oneof_content[brace_start + 1..brace_end];

    // Parse each field in the oneof, looking for @zenoh markers
    let mut next_has_zenoh = false;

    for line in oneof_block.lines() {
        let line = line.trim();

        // Check for @zenoh marker in comment-only lines
        if line.starts_with("//") {
            if line.contains("@zenoh") {
                next_has_zenoh = true;
            }
            continue;
        }

        if line.is_empty() || line.starts_with("reserved") || line.starts_with('[') {
            continue;
        }

        // Check if this line has @zenoh marker (inline) or previous comment had it
        let has_zenoh = next_has_zenoh || line.contains("@zenoh");
        next_has_zenoh = false;

        if !has_zenoh {
            continue;
        }

        // Extract the field name (before the = sign)
        if let Some(eq_pos) = line.find('=') {
            let before_eq = line[..eq_pos].trim();
            // Split by whitespace, the last word is the field name
            let parts: Vec<&str> = before_eq.split_whitespace().collect();
            if parts.len() >= 2 {
                let field_name = parts[parts.len() - 1];
                let variant_name = to_pascal_case(field_name);
                payloads.push((variant_name, field_name.to_string()));
            }
        }
    }

    payloads
}

/// Converts a snake_case or camelCase string to PascalCase.
/// Handles common patterns like "2dtof" -> "2dTof"
fn to_pascal_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;

    for c in s.chars() {
        if c == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}

/// Converts a PascalCase string to snake_case.
fn to_snake_case(s: &str) -> String {
    let mut result = String::new();

    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }

    result
}

/// To run these tests:
/// `rustc --test build.rs -o /tmp/build_test && /tmp/build_test`
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_snake_case() {
        assert_eq!(to_snake_case("AmbientLight"), "ambient_light");
        assert_eq!(to_snake_case("Tamper"), "tamper");
        assert_eq!(to_snake_case("BatteryVoltage"), "battery_voltage");
        assert_eq!(to_snake_case("IMUData"), "i_m_u_data");
    }

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("ambient_light"), "AmbientLight");
        assert_eq!(to_pascal_case("tamper"), "Tamper");
        assert_eq!(to_pascal_case("battery_voltage"), "BatteryVoltage");
    }

    #[test]
    fn test_extract_oneof_payloads_inline_zenoh() {
        // @zenoh marker on the same line as the field
        let proto = r#"
message TestMessage {
    oneof payload {
        SomeType field_one = 1; // @zenoh
        OtherType field_two = 2;
        AnotherType field_three = 3; // @zenoh some extra comment
    }
}
"#;
        let payloads = extract_oneof_payloads(proto, "TestMessage");
        assert_eq!(payloads.len(), 2);
        assert_eq!(
            payloads[0],
            ("FieldOne".to_string(), "field_one".to_string())
        );
        assert_eq!(
            payloads[1],
            ("FieldThree".to_string(), "field_three".to_string())
        );
    }

    #[test]
    fn test_extract_oneof_payloads_preceding_line_zenoh() {
        // @zenoh marker on the line before the field (formatter style)
        let proto = r#"
message TestMessage {
    oneof payload {
        // @zenoh
        SomeType field_one = 1;
        OtherType field_two = 2;
        // @zenoh
        AnotherType field_three = 3;
    }
}
"#;
        let payloads = extract_oneof_payloads(proto, "TestMessage");
        assert_eq!(payloads.len(), 2);
        assert_eq!(
            payloads[0],
            ("FieldOne".to_string(), "field_one".to_string())
        );
        assert_eq!(
            payloads[1],
            ("FieldThree".to_string(), "field_three".to_string())
        );
    }

    #[test]
    fn test_extract_oneof_payloads_mixed_styles() {
        // Mix of inline and preceding line markers
        let proto = r#"
message TestMessage {
    oneof payload {
        // @zenoh
        SomeType field_one = 1;
        OtherType field_two = 2; // @zenoh
        AnotherType field_three = 3;
        // @zenoh - this field is important
        FourthType field_four = 4;
    }
}
"#;
        let payloads = extract_oneof_payloads(proto, "TestMessage");
        assert_eq!(payloads.len(), 3);
        assert_eq!(
            payloads[0],
            ("FieldOne".to_string(), "field_one".to_string())
        );
        assert_eq!(
            payloads[1],
            ("FieldTwo".to_string(), "field_two".to_string())
        );
        assert_eq!(
            payloads[2],
            ("FieldFour".to_string(), "field_four".to_string())
        );
    }

    #[test]
    fn test_extract_oneof_payloads_zenoh_with_extra_comments() {
        // @zenoh marker can have extra text around it
        let proto = r#"
message TestMessage {
    oneof payload {
        // Some description @zenoh for this field
        SomeType field_one = 1;
        OtherType field_two = 2; // comment @zenoh another comment
    }
}
"#;
        let payloads = extract_oneof_payloads(proto, "TestMessage");
        assert_eq!(payloads.len(), 2);
        assert_eq!(
            payloads[0],
            ("FieldOne".to_string(), "field_one".to_string())
        );
        assert_eq!(
            payloads[1],
            ("FieldTwo".to_string(), "field_two".to_string())
        );
    }

    #[test]
    fn test_extract_oneof_payloads_no_zenoh_markers() {
        let proto = r#"
message TestMessage {
    oneof payload {
        SomeType field_one = 1;
        OtherType field_two = 2;
    }
}
"#;
        let payloads = extract_oneof_payloads(proto, "TestMessage");
        assert!(payloads.is_empty());
    }

    #[test]
    fn test_extract_oneof_payloads_message_not_found() {
        let proto = r#"
message OtherMessage {
    oneof payload {
        SomeType field_one = 1; // @zenoh
    }
}
"#;
        let payloads = extract_oneof_payloads(proto, "TestMessage");
        assert!(payloads.is_empty());
    }

    #[test]
    fn test_extract_oneof_payloads_with_reserved_and_empty_lines() {
        let proto = r#"
message TestMessage {
    oneof payload {
        reserved 5, 6;

        // @zenoh
        SomeType field_one = 1;

        OtherType field_two = 2;

        // @zenoh
        AnotherType field_three = 3;
    }
}
"#;
        let payloads = extract_oneof_payloads(proto, "TestMessage");
        assert_eq!(payloads.len(), 2);
        assert_eq!(
            payloads[0],
            ("FieldOne".to_string(), "field_one".to_string())
        );
        assert_eq!(
            payloads[1],
            ("FieldThree".to_string(), "field_three".to_string())
        );
    }

    #[test]
    fn test_extract_oneof_payloads_zenoh_with_description_comments() {
        // @zenoh on comment line followed by other description comments still applies to the field
        let proto = r#"
message TestMessage {
    oneof payload {
        // @zenoh
        // This is a description for field_one
        SomeType field_one = 1;
        OtherType field_two = 2; // @zenoh
    }
}
"#;
        let payloads = extract_oneof_payloads(proto, "TestMessage");
        // @zenoh marker persists across description comments until the next field
        assert_eq!(payloads.len(), 2);
        assert_eq!(
            payloads[0],
            ("FieldOne".to_string(), "field_one".to_string())
        );
        assert_eq!(
            payloads[1],
            ("FieldTwo".to_string(), "field_two".to_string())
        );
    }
}
